getRedirectResult() still returns null for Mikeâ€™s browser/account.

This is common for certain browsers (Safari, iOS, strict privacy modes) where session cookies are lost during the redirect flow.

That explains why yours works (Chrome desktop most likely) but Mikeâ€™s does not.

The fallback signInWithPopup() is implemented only in RedirectHandler.tsx, but it triggers only after the user hits the handler route.

On the auth page (/auth), the â€œpopup fallbackâ€ button exists â€” but itâ€™s manual and does nothing to auto-correct if redirect flow fails.

ğŸª„ What Needs to Change
âœ… Rather than attempting signInWithRedirect() by default and hoping it works, we should:
1ï¸âƒ£ Detect browser support for redirect flow.
2ï¸âƒ£ Use signInWithPopup() by default, and leave signInWithRedirect() as an optional fallback.
3ï¸âƒ£ Keep RedirectHandler.tsx simple and stop trying to â€œrescueâ€ after failure.

This is a best practice per Firebaseâ€™s own documentation for environments where session loss is common.

ğŸš€ Clean Fix: Code Changes
1ï¸âƒ£ firebase-auth-page.tsx
In the main auth page, change the Google sign-in button to use signInWithPopup() directly:

tsx
Copy
Edit
<Button
  onClick={async () => {
    try {
      await signInWithGooglePopup();
      setLocation("/dashboard");
    } catch (err) {
      console.error("Popup login failed", err);
    }
  }}
>
  Continue with Google
</Button>
Remove any code that calls signInWithRedirect() by default.

2ï¸âƒ£ RedirectHandler.tsx
You can actually remove the fallback here entirely.
It can just show a message that â€œYour session expired, please try againâ€ if getRedirectResult() returns null.

tsx
Copy
Edit
useEffect(() => {
  const processRedirect = async () => {
    console.log("=== RedirectHandler: Processing OAuth redirect ===");

    try {
      const result = await getRedirectResult(auth);
      if (result?.user) {
        const idToken = await result.user.getIdToken();
        await apiRequest("POST", "/api/firebase/sync-user", { idToken });
        navigate("/dashboard");
      } else {
        console.warn("RedirectHandler: getRedirectResult() returned null.");
        navigate("/auth?error=session");
      }
    } catch (err) {
      console.error("RedirectHandler: Auth failed", err);
      navigate("/auth?error=auth");
    }
  };

  processRedirect();
}, [navigate]);
3ï¸âƒ£ use-firebase-auth.tsx
âœ… Keep the signInWithPopup() method exactly as written â€” no changes needed.

ğŸ“ Why This Works
âœ… Redirect flow simply does not work reliably in privacy-heavy browsers or mobile.
âœ… Popup flow is faster and more reliable for 99% of use cases.
âœ… Keeps logic clean: no weird fallback hacks or state confusion.
âœ… Still keeps the /__/auth/handler route for users who land there (but it simply instructs them to retry).

ğŸ§ª What to Tell Replit
We need to stop defaulting to signInWithRedirect() and instead use signInWithPopup() as the default login method on /auth.

Please update firebase-auth-page.tsx to have the main â€œContinue with Googleâ€ button trigger signInWithGooglePopup(), then navigate to /dashboard on success.

Update RedirectHandler.tsx to just show an error and navigate back to /auth if getRedirectResult() is null â€” no more automatic fallback.

This is the recommended best practice for iOS/Safari and other privacy-mode browsers that donâ€™t persist session state properly during redirect.

Once this is implemented, Mikeâ€™s login should succeed via popup even on his device. Please deploy this change and test.

âœ… This is clean, reliable, and the recommended way to handle cross-browser auth. If you want, I can also bundle the ready-to-drop firebase-auth-page.tsx and RedirectHandler.tsx code files